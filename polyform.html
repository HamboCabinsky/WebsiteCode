<!DOCTYPE html>
<html lang="">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PolyForm</title>
    <style> 
    </style>
    <link rel="stylesheet" media="screen" href="defstylsh.css">
    <link rel="shortcut icon" type="image/jpg" href="painty.jpg">
    <script src="https://d3js.org/d3.v4.min.js"></script>
  </head>
  <body>
      <div class="nav">
      <a href="index.html">Home</a>
      <a href="cards.html">Guessing Game</a>
      <a href="GUI-tar.html">GUI-tar</a>
      <a href="polyform.html" class="active">PolyForm</a>
      </div>
      <br>
      <section class="title-container">
            <h1 id="title">PolyForm</h1>
            <p class="sub-title">Work in Progress!</p>
      </section>
      <br>
    <main>
      <div id='d3cont'></div>
    </main>

  </body>

<script>

    let screen_width  = screen.width;
    let width = Math.floor(screen_width/2.8);
    let height = Math.floor(screen_width/2.8);
    let last_click = null;
    let colors = ['black', 'white', 'pink', 'red', 'orange', 'yellow', 'green', 'cyan', 'blue', 'purple'];
    let shapes = [];
    let points = [];
    let point_elems = [];
    let selected = [];

    let svg = d3.select("#d3cont")
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                //center svg on page
                .attr("transform", "translate(".concat(Math.floor(screen_width/2-width/2), ",0)"));


    let border_n_grid = svg.append("g");
    let main_node = svg.append("g");
    main_node.attr("id","main_node");
    
    let grid_tile_size = 50;
    let g_rows = Math.floor(width/grid_tile_size);
    let g_cols = Math.floor(height/grid_tile_size);

    if (width%grid_tile_size != 0) g_rows++;
    if (g_cols%grid_tile_size != 0) g_cols++;


    for(let r = 0; r < g_rows; r++)
    {
      for(let c = 0; c < g_cols; c++)
      {
        if(r%2 ==0)
        {
          if(c%2 == 0)
          {
            border_n_grid.append("rect")
                         .attr("x",r*grid_tile_size)                        
                         .attr("y",c*grid_tile_size)
                         .attr("width",grid_tile_size)
                         .attr("height",grid_tile_size)
                         .attr("fill", "gainsboro");
          }
          else
          {
            border_n_grid.append("rect")
                         .attr("x",r*grid_tile_size)                        
                         .attr("y",c*grid_tile_size)
                         .attr("width",grid_tile_size)
                         .attr("height",grid_tile_size)
                         .attr("fill", "white");
          }
        }
        else
        {
          if(c%2 == 1)
          {
            border_n_grid.append("rect")
                         .attr("x",r*grid_tile_size)                        
                         .attr("y",c*grid_tile_size)
                         .attr("width",grid_tile_size)
                         .attr("height",grid_tile_size)
                         .attr("fill", "gainsboro");
          }
          else
          {
            border_n_grid.append("rect")
                         .attr("x",r*grid_tile_size)                        
                         .attr("y",c*grid_tile_size)
                         .attr("width",grid_tile_size)
                         .attr("height",grid_tile_size)
                         .attr("fill", "white");
          }
        }
      }
    }

    border_n_grid.append("rect")
                 .attr("width", width)
                 .attr("height", height)
                 .attr("fill", "none")
                 .attr("stroke", "black")
                 .attr("stroke-width", 4);

    svg.on("click", function(){
      last_click = d3.mouse(this);
      point_elems.push(main_node.append("circle")
                                .attr("cx", last_click[0])
                                .attr("cy", last_click[1])
                                .attr("r", 2)
                                .attr("fill", colors[0]));
      points.push(last_click);
      });

    svg.on("contextmenu", function(){
              d3.event.preventDefault();
        });

    d3.select(window).on('keypress', function(){
      let k = d3.event.key;
      //top row of letter keys correspond to the 10 colors we can choose from to fill a polygon
      if(k == 'q' || k == 'w' || k == 'e' || k == 'r' || k == 't' || k == 'y' || k == 'u' || k == 'i' || k == 'o' || k == 'p')
      {
        let color;

        switch(k){
          case "q":
            color = colors[0];
            break;
          case "w":
            color = colors[1];
            break;
          case "e":
            color = colors[2];
            break;
          case "r":
            color = colors[3];
            break;
          case "t":
            color = colors[4];
            break;
          case "y":
            color = colors[5];
            break;
          case "u":
            color = colors[6];
            break;
          case "i":
            color = colors[7];
            break;
          case "o":
            color = colors[8];
            break;
          case "p":
            color = colors[9];
            break;

        }

        if(points.length > 2)
        {
          let pointsStr = "";
          pointsStr = pointsStr.concat(points[0][0],",",points[0][1]);

          for(let i = 1; i < points.length; i++)
          {
            pointsStr = pointsStr.concat(" ",points[i][0],",",points[i][1]);
          }
          
          shapes.push(main_node.append("polygon")
                               .attr("points", pointsStr)
                               .attr("fill", color)
                               .on("contextmenu", function()
                               {

                                let index = selected.indexOf(this);
                                if(index == -1)
                                {
                                  selected.push(this);
                                  d3.select(this).attr('stroke-width', 4)
                                                 .attr('stroke', "gold");
                                }
                                else
                                {
                                  selected.splice(index,1);
                                  d3.select(this).attr('stroke-width', 0);
                                }
                                
                               }
                               ));
          point_elems.forEach(point => point.remove());
          points = [];
          point_elems = [];
        }
      }  
    });

    document.onkeydown = checkKey;

    function cloneElem(elem)
    {
      shapes.push(d3.select(elem).clone([true]));
      shapes[shapes.length-1].attr('stroke-width', 0)
                             .on("contextmenu", function()
                                   {
                                    let index = selected.indexOf(this);
                                    if(index == -1)
                                    {
                                      selected.push(this);
                                      d3.select(this).attr('stroke-width', 4)
                                                     .attr('stroke', "gold");
                                    }
                                    else
                                    {
                                      selected.splice(index,1);
                                      d3.select(this).attr('stroke-width', 0);
                                    }
                                   });
  };

  //remove a selected element
  function removeElem(elem)
  {
    d3.select(elem).remove();
    for(let i = 0; i < shapes.length; i++)
    {
      if(elem == shapes[i]._groups[0][0]) return shapes.splice(i,1);
    }
    return null;
  }

  //get translation x & y from a d3 selection element
  function getTranslation(elem)
  {
    let translate = [0,0];
    let transform_str = elem.attr("transform");

    //return [0,0] if we havent yet done any transformation on selected shape
    if(transform_str == null) return translate;

    let translateStrInd = transform_str.indexOf("translate");

    //if we haven't translated element return [0,0]
    if(translateStrInd == -1) return translate;

    //otherwise parse transform string for translation x and y values
    let tslStrStart = transform_str.indexOf("(", translateStrInd)+1;
    let tslStrY = transform_str.indexOf(",", tslStrStart)+1;
    let tslStrEnd = transform_str.indexOf(")", tslStrY);
    translate[0] = parseInt(transform_str.substring(tslStrStart,tslStrY-1));
    translate[1] = parseInt(transform_str.substring(tslStrY,tslStrEnd));

    return translate;
  }

  //get rotation of a d3 selection element
  function getRotation(elem)
  {
    let rotation = [0,0,0];
    let transform_str = elem.attr("transform");
    let num_elems;

    //return [0,0] if we havent yet done any transformation on selected shape
    if(transform_str == null) return rotation;

    let rotationStrInd = transform_str.indexOf("rotate");

    //if we haven't rotated element return [0,0,0]
    if(rotationStrInd == -1) return rotation;

    //otherwise parse transform string for translation x and y values
    let rotStrStart = transform_str.indexOf("(", rotationStrInd)+1;
    let rotStrX = transform_str.indexOf(",", rotStrStart)+1;
    let rotStrEnd = transform_str.indexOf(")", rotStrStart);

    if(rotStrX == -1 || rotStrX > rotStrEnd) num_elems = 1;
    else num_elems = 3;

    if(num_elems == 1)
    {
      rotation[0] = parseInt(transform_str.substring(rotStrStart,rotStrEnd));
    }
    else
    {
      //degrees
      rotation[0] = parseInt(transform_str.substring(rotStrStart,rotStrX-1));
      let rotStrY = transform_str.indexOf(",", rotStrX)+1;
      //x,y value to rotate around
      rotation[1] = parseInt(transform_str.substring(rotStrX,rotStrY-1));
      rotation[2] = parseInt(transform_str.substring(rotStrY,rotStrEnd));
    }

    return rotation;
  }

  //rotate everything in selected around midpoint of selected objects
  function rotateSelected(degrees)
  {

    if (selected.length == 0) return false;

    let xSum = 0;
    let ySum = 0;
    let num_values = 0;
    let sel_elem = null;
    let pt_list = null;

    for(let i = 0; i < selected.length; i++)
    {
      sel_elem = d3.select(selected[i]);
      pt_list = sel_elem._groups[0][0].points;

      for(let j = 0; j < pt_list.length; j++)
      {
        xSum += sel_elem._groups[0][0].points[j].x;
        ySum += sel_elem._groups[0][0].points[j].y;
        num_values++;
      }

      let origin = [Math.floor(xSum/num_values), Math.floor(ySum/num_values)];

      xSum = 0;
      ySum = 0;
      num_values = 0;

      let transform_str = d3.select(selected[i]).attr("transform");
      let rotation = getRotation(d3.select(selected[i]));

      //if we havent done any transformations yet, no other pieces of string to worry about
      if(transform_str == null) 
      {
        d3.select(selected[i]).attr("transform", "rotate(".concat(rotation[0] + degrees, ",", origin[0], ",", origin[1], ")"));
        continue;
      }
      

      let rotateInd = transform_str.indexOf("rotate");

      //if we've already rotated, need to insert translation into proper place in string
      if(rotateInd != -1 || (origin[0] == rotation[1] && origin[1] == rotation[2]))
      {
        let rotateEnd = transform_str.indexOf(")", rotateInd);
        let newTFb4 = transform_str.slice(0, rotateInd);
        let newTFAfter = transform_str.slice(rotateEnd+1, transform_str.length);
        let TFInsert ="rotate(".concat(rotation[0] + degrees, ",", origin[0], ",", origin[1], ")");
        d3.select(selected[i]).attr("transform", newTFb4 + newTFAfter + TFInsert);
      }
      else
      {
        d3.select(selected[i]).attr("transform", transform_str.concat(" rotate(".concat(rotation[0] + degrees, ",", origin[0], ",", origin[1], ")")));
      }
    }

    return true;
  }

  function checkKey(e)
  {
    //console.log(e.keyCode);
    //arrow keys, translate selected
    if(e.keyCode >= 37 && e.keyCode <= 40)
    {
      e.preventDefault();
      let toTranslate;

      switch(e.keyCode)
      {
        case 37:
          toTranslate = [-4,0];
          break;
        case 38:
          toTranslate = [0,-4];
          break;
        case 39:
          toTranslate = [4,0];
          break;
        case 40:
          toTranslate = [0,4];
          break;
      }
      
      for(let i = 0; i < selected.length; i++)
      {
        //transform property as string
        let t = getTranslation(d3.select(selected[i]));
        let final_toT = [toTranslate[0],toTranslate[1]];
        if(t)
        {
          final_toT[0] += t[0];
          final_toT[1] += t[1];
        }

        let transform_str = d3.select(selected[i]).attr("transform");

        //if we havent done any transformations yet, no other pieces of string to worry about
        if(transform_str == null) 
        {
          d3.select(selected[i]).attr("transform", "translate(".concat(final_toT[0],",",final_toT[1],")"));
          continue;
        }

        let translateInd = transform_str.indexOf("translate");

        //if we've already translated, need to insert translation into proper place in string
        if(translateInd != -1)
        {
          let translateEnd = transform_str.indexOf(")", translateInd);
          let newTFb4 = transform_str.slice(0, translateInd);
          let newTFAfter = transform_str.slice(translateEnd+1, transform_str.length);
          let TFInsert = "translate(".concat(final_toT[0],",",final_toT[1],")");
          d3.select(selected[i]).attr("transform", newTFb4 + TFInsert + newTFAfter);
        }
        else
        {
          d3.select(selected[i]).attr("transform", "translate(".concat(final_toT[0],",",final_toT[1],") ").concat(transform_str));
        }
        
      }
    }
    //if enter key is pressed, duplicate selected
    else if(e.keyCode == 13)
    {
      selected.forEach(elem => cloneElem(elem));
    }
    //if backspace pressed, delete selected
    else if (e.keyCode == 8)
    {
      selected.forEach(elem => removeElem(elem));
      selected = [];
    }
    //if < or > pressed, rotate selected
    else if(e.keyCode == 188 || e.keyCode == 190)
    {
      if(e.keyCode == 188) rotateSelected(-2);
      else rotateSelected(2);
    }
  };

  </script>

</html>